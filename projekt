using System;
Â 
using System.Collections.Generic;
Â 
using System.Threading;
Â 
class Program
Â 
{
Â 
Â Â Â  struct Point { public int X, Y; public Point(int x, int y) { X = x; Y = y; } }
Â 
Â Â Â  static int width = 20;
Â 
Â Â Â  static int height = 20;
Â 
Â Â Â  static LinkedList<Point> snake = new LinkedList<Point>();
Â 
Â Â Â  static HashSet<int> snakeSet = new HashSet<int>();
Â 
Â Â Â  static Point food;
Â 
Â Â Â  static Random rnd = new Random();
Â 
Â Â Â  static int score = 0;
Â 
Â Â Â  static int speed = 120;
Â 
Â Â Â  static int dx = 1, dy = 0;
Â 
Â Â Â  static bool gameOver = false;
Â 
Â Â Â  static bool directionChanged = false;
Â 
Â Â Â  static object lockObj = new object();
Â 
Â Â Â  static void Main()
Â 
Â Â Â  {
Â 
Â Â Â Â Â Â Â  Console.OutputEncoding = System.Text.Encoding.UTF8;
Â 
Â Â Â Â Â Â Â  Console.CursorVisible = false;
Â 
Â Â Â Â Â Â Â  InitGame();
Â 
Â Â Â Â Â Â Â  Thread inputThread = new Thread(InputLoop) { IsBackground = true };
Â 
Â Â Â Â Â Â Â  inputThread.Start();
Â 
Â Â Â Â Â Â Â  DrawBorder();
Â 
Â Â Â Â Â Â Â  DrawScore();
Â 
Â Â Â Â Â Â Â  foreach (var p in snake) DrawAt(p.X, p.Y, "@");
Â 
Â Â Â Â Â Â Â  PlaceFood();
Â 
Â Â Â Â Â Â Â  DrawAt(food.X, food.Y, "*");
Â 
Â Â Â Â Â Â Â  while (!gameOver)
Â 
Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â  Thread.Sleep(speed);
Â 
Â Â Â Â Â Â Â Â Â Â Â  Update();
Â 
Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â  Console.SetCursorPosition(0, height + 3);
Â 
Â Â Â Â Â Â Â  Console.CursorVisible = true;
Â 
Â Â Â Â Â Â Â  Console.WriteLine();
Â 
Â Â Â Â Â Â Â  Console.WriteLine($"ğŸ’€ Game Over!Â  Score: {score} ğŸ†");
Â 
Â Â Â Â Â Â Â  Console.WriteLine("Press any key to exit...");
Â 
Â Â Â Â Â Â Â  Console.ReadKey(true);
Â 
Â 
Â Â Â  }
Â 
Â Â Â  static void InitGame()
Â 
Â Â Â  {
Â 
Â Â Â Â Â Â Â  lock (lockObj)
Â 
Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â  snake.Clear();
Â 
Â Â Â Â Â Â Â Â Â Â Â  snakeSet.Clear();
Â 
Â Â Â Â Â Â Â Â Â Â Â  int startX = width / 2;
Â 
Â Â Â Â Â Â Â Â Â Â Â  int startY = height / 2;
Â 
Â Â Â Â Â Â Â Â Â Â Â  for (int i = 0; i < 4; i++)
Â 
Â Â Â Â Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  var p = new Point(startX - i, startY);
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  snake.AddLast(p);
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  snakeSet.Add(ToKey(p.X, p.Y));
Â 
Â Â Â Â Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â Â Â Â Â  dx = 1; dy = 0;
Â 
Â Â Â Â Â Â Â Â Â Â Â  score = 0;
Â 
Â Â Â Â Â Â Â Â Â Â Â  speed = 120;
Â 
Â Â Â Â Â Â Â Â Â Â Â  gameOver = false;
Â 
Â Â Â Â Â Â Â Â Â Â Â  Console.Clear();
Â 
Â Â Â Â Â Â Â  }
Â 
Â Â Â  }
Â 
Â Â Â  static void InputLoop()
Â 
Â Â Â  {
Â 
Â Â Â Â Â Â Â  while (!gameOver)
Â 
Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â  if (Console.KeyAvailable)
Â 
Â Â Â Â Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  var key = Console.ReadKey(true).Key;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  lock (lockObj)
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (directionChanged) continue;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (key == ConsoleKey.W && !(dx == 0 && dy == 1)) { dx = 0; dy = -1; directionChanged = true; }
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  else if (key == ConsoleKey.S && !(dx == 0 && dy == -1)) { dx = 0; dy = 1; directionChanged = true; }
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  else if (key == ConsoleKey.A && !(dx == 1 && dy == 0)) { dx = -1; dy = 0; directionChanged = true; }
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  else if (key == ConsoleKey.D && !(dx == -1 && dy == 0)) { dx = 1; dy = 0; directionChanged = true; }
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  else if (key == ConsoleKey.Escape) gameOver = true;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â Â Â Â Â  else Thread.Sleep(10);
Â 
Â Â Â Â Â Â Â  }
Â 
Â Â Â  }
Â 
Â Â Â  static void Update()
Â 
Â Â Â  {
Â 
Â Â Â Â Â Â Â  lock (lockObj)
Â 
Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â  var head = snake.First.Value;
Â 
Â Â Â Â Â Â Â Â Â Â Â  int nx = head.X + dx;
Â 
Â Â Â Â Â Â Â Â Â Â Â  int ny = head.Y + dy;
Â 
Â Â Â Â Â Â Â Â Â Â Â  if (nx < 1 || nx > width || ny < 1 || ny > height)
Â 
Â Â Â Â Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  gameOver = true;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return;
Â 
Â Â Â Â Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â Â Â Â Â  int key = ToKey(nx, ny);
Â 
Â Â Â Â Â Â Â Â Â Â Â  if (snakeSet.Contains(key))
Â 
Â Â Â Â Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  gameOver = true;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return;
Â 
Â Â Â Â Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â Â Â Â Â  var newHead = new Point(nx, ny);
Â 
Â Â Â Â Â Â Â Â Â Â Â  snake.AddFirst(newHead);
Â 
Â Â Â Â Â Â Â Â Â Â Â  snakeSet.Add(ToKey(newHead.X, newHead.Y));
Â 
Â Â Â Â Â Â Â Â Â Â Â  DrawAt(newHead.X, newHead.Y, "@");
Â 
Â Â Â Â Â Â Â Â Â Â Â  if (snake.Count > 1)
Â 
Â Â Â Â Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  var second = snake.First.Next.Value;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  DrawAt(second.X, second.Y, "@");
Â 
Â Â Â Â Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â Â Â Â Â  if (nx == food.X && ny == food.Y)
Â 
Â Â Â Â Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  score++;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (score % 3 == 0 && speed > 30) speed -= 8;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  DrawScore();
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  PlaceFood();
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  DrawAt(food.X, food.Y, "*");
Â 
Â Â Â Â Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â Â Â Â Â  else
Â 
Â Â Â Â Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  var tail = snake.Last.Value;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  DrawAt(tail.X, tail.Y, "Â  ");
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  snakeSet.Remove(ToKey(tail.X, tail.Y));
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  snake.RemoveLast();
Â 
Â Â Â Â Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â Â Â Â Â  directionChanged = false;
Â 
Â Â Â Â Â Â Â  }
Â 
Â Â Â  }
Â 
Â Â Â  static void PlaceFood()
Â 
Â Â Â  {
Â 
Â Â Â Â Â Â Â  lock (lockObj)
Â 
Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â  int fx, fy;
Â 
Â Â Â Â Â Â Â Â Â Â Â  int attempts = 0;
Â 
Â Â Â Â Â Â Â Â Â Â Â  do
Â 
Â Â Â Â Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  fx = rnd.Next(1, width + 1);
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  fy = rnd.Next(1, height + 1);
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  attempts++;
Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (attempts > 10000) break;
Â 
Â Â Â Â Â Â Â Â Â Â Â  } while (snakeSet.Contains(ToKey(fx, fy)));
Â 
Â Â Â Â Â Â Â Â Â Â Â  food = new Point(fx, fy);
Â 
Â Â Â Â Â Â Â  }
Â 
Â Â Â  }
Â 
Â Â Â  static void DrawBorder()
Â 
Â Â Â  {
Â 
Â Â Â Â Â Â Â  Console.SetCursorPosition(0, 0);
Â 
Â Â Â Â Â Â Â  Console.Write("# ");
Â 
Â Â Â Â Â Â Â  for (int x = 1; x <= width; x++) Console.Write("# ");
Â 
Â Â Â Â Â Â Â  Console.WriteLine("# ");
Â 
Â Â Â Â Â Â Â  for (int y = 1; y <= height; y++)
Â 
Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â  Console.Write("# ");
Â 
Â Â Â Â Â Â Â Â Â Â Â  for (int x = 1; x <= width; x++) Console.Write("Â  ");
Â 
Â Â Â Â Â Â Â Â Â Â Â  Console.WriteLine("# ");
Â 
Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â  Console.Write("# ");
Â 
Â Â Â Â Â Â Â  for (int x = 1; x <= width; x++) Console.Write("# ");
Â 
Â Â Â Â Â Â Â  Console.WriteLine("# ");
Â 
Â Â Â  }
Â 
Â Â Â  static void DrawScore()
Â 
Â Â Â  {
Â 
Â Â Â Â Â Â Â  Console.SetCursorPosition(0, height + 1);
Â 
Â Â Â Â Â Â Â  Console.Write($"ğŸ† Score: {score}Â Â  âš¡ Speed: {Math.Max(1, 200 - speed)}Â Â  ğŸ® Move: W/A/S/DÂ Â  âŒ Quit (Esc)".PadRight(width * 2 + 4));
Â 
Â Â Â  }
Â 
Â Â Â  static void DrawAt(int x, int y, string c)
Â 
Â Â Â  {
Â 
Â Â Â Â Â Â Â  try
Â 
Â Â Â Â Â Â Â  {
Â 
Â Â Â Â Â Â Â Â Â Â Â  Console.SetCursorPosition(x * 2, y);
Â 
Â Â Â Â Â Â Â Â Â Â Â  Console.Write(c);
Â 
Â Â Â Â Â Â Â  }
Â 
Â Â Â Â Â Â Â  catch { }
Â 
Â Â Â  }
Â 
Â Â Â  static int ToKey(int x, int y) => x + y * (width + 2);
Â 
}
